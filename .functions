#!/bin/bash
### Modified from https://github.com/mathiasbynens/dotfiles

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
  local tmpFile="${@%/}.tar"
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
  )

  local cmd=""
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli"
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi
  fi

  echo "Compressing .tar using \`${cmd}\`â€¦"
  "${cmd}" -v "${tmpFile}" || return 1
  [ -f "${tmpFile}" ] && rm "${tmpFile}"
  echo "${tmpFile}.gz created successfully."
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# Compare original and gzipped file size
function gz() {
  local origsize=$(wc -c < "$1")
  local gzipsize=$(gzip -c "$1" | wc -c)
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
  printf "orig: %d bytes\n" "$origsize"
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Install Grunt plugins and add them as `devDependencies` to `package.json`
# Usage: `gi contrib-watch contrib-uglify zopfli`
function gi() {
  local IFS=,
  eval npm install --save-dev grunt-{"$*"}
}

# # `m` with no arguments opens the current directory in TextMate, otherwise
# # opens the given location
# function m() {
#   if [ $# -eq 0 ]; then
#     mate .
#   else
#     mate "$@"
#   fi
# }

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
function s() {
  if [ $# -eq 0 ]; then
    subl .
  else
    subl "$@"
  fi
}

# `o` with no arguments opens current directory, otherwise opens the given
# location
function o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "$@"
  fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

mkcd () {
  # about 'make a directory and cd into it'
  # param 'path to create'
  # example '$ mkcd foo'
  # example '$ mkcd /tmp/img/photos/large'
  mkdir -p "$*"
  cd "$*"
}

function keygen() {
  KEY="$HOME/.ssh/id_dsa.pub"
  # make sure we have a public key (check id_dsa.pub, then id_rsa.pub)
  if [ ! -f ${KEY} ]; then
    KEY="$HOME/.ssh/id_rsa.pub"
    if [ ! -f ${KEY} ]; then
      echo "private key not found at ${KEY}"
      echo "* please create it with "ssh-keygen -t rsa" *"
      echo "* to login to the remote host without a password, don't give the key you create with ssh-keygen a password! *"
      exit
    fi
  fi


  # need at least a user specified
  if [ -z $1 ]; then
      echo "\nSSH Key Generator"
      echo "Example usage:"
      echo "\t~./path/keygen.sh username servername\n"
      echo "Default server name is stewie.fusionary.com."
      echo "Servers 'stewie' and 'quinn' resolve to 'stewie.fusionary.com' and 'quinn.fusionary.com'"
      exit
  fi

  USR="$1"

  # server will be stewie.fusionary.com, unless otherwise specified.
  SERVER="$2"
  SERVER=${SERVER:=stewie.fusionary.com}

  # if user chooses "stewie" or "quinn," then ".fusionary.com" is appended
  if [ ${SERVER} = "stewie" ] || [ ${SERVER} = "quinn" ]; then
    SERVER="${SERVER}.fusionary.com"
  fi

  echo "Putting your key on ${SERVER}... "

  # put the key on the server
  cat ${KEY} | ssh -l ${USR} ${SERVER} 'cat >> .ssh/authorized_keys'
  echo "generated key for ${USR} on ${SERVER}"
}

