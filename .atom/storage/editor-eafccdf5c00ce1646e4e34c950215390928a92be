{"version":1,"windowDimensions":{"x":44,"y":23,"width":1396,"height":873,"maximized":false},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/usr/local/Cellar/git-extras/3.0.0"],"buffers":[{"text":"#!/usr/bin/env bash\n# reset environment variables that could interfere with normal usage\nexport GREP_OPTIONS=\n# put all utility functions here\n\n# make a temporary file\ngit_extra_mktemp() {\n    mktemp -t \"$(basename \"$0\")\".XXX\n}\n\n#\n# check whether current directory is inside a git repository\n#\n\nis_git_repo() {\n  git rev-parse --show-toplevel > /dev/null 2>&1\n  result=$?\n  if test $result != 0; then\n    >&2 echo 'Not a git repo!'\n    exit $result\n  fi\n}\n\nis_git_repo\n\nDEF_TAG_RECENT=\"n.n.n\"\nGIT_LOG_OPTS=\"$(git config changelog.opts)\"\nGIT_LOG_FORMAT=\"$(git config changelog.format)\"\n[[ -z \"$GIT_LOG_FORMAT\" ]] && GIT_LOG_FORMAT='  * %s'\nGIT_EDITOR=\"$(git var GIT_EDITOR)\"\nPROGNAME=\"git-changelog\"\n\n_usage() {\ncat << EOF\nusage: $PROGNAME options [file]\nusage: $PROGNAME -h|help|?\n\nGenerate a Changelog from git(1) tags (annotated or lightweight) and commit\nmessages. Existing Changelog files with filenames that begin with 'Change' or\n'History' will be identified automatically and their content will be appended\nto the new output generated (unless the -p|--prune-old option is used). If no\ntags exist, then all commits are output; if tags exist, then only the most-\nrecent commits are output up to the last identified tag.\n\nOPTIONS:\n  -a, --all                 Retrieve all commits (ignores --start-tag, --final-tag)\n  -l, --list                Display commits as a list, with no titles\n  -t, --tag                 Tag label to use for most-recent (untagged) commits\n  -f, --final-tag           Newest tag to retrieve commits from in a range\n  -s, --start-tag           Oldest tag to retrieve commits from in a range\n  -n, --no-merges           Suppress commits from merged branches\n  -p, --prune-old           Replace existing Changelog entirely with new content\n  -x, --stdout              Write output to stdout instead of to a Changelog file\n  -h, --help, ?             Show this message\nEOF\n}\n\n_error() {\n  [ $# -eq 0 ] && _usage && exit 0\n\n  echo\n  echo \"ERROR: \" \"$@\"\n  echo\n}\n\n# _setValueForKeyFakeAssocArray()\n# /*!\n# @abstract Set value for key from a fake associative array\n# @discussion\n# Iterates over target_ary (an indexed array), searching for target_key, if the\n#   key is found its value is set to new_value otherwise the target_key and\n#   new_value are appended to the array.\n#\n#   The indexed array values must conform to this format:\n#     \"key:value\"\n#   Where key and value are separated by a single colon character.\n#\n#   Specify empty values as an empty, quoted string.\n#\n#   So-called \"fake\" associative arrays are useful for environments where the\n#   installed version of bash(1) precedes 4.0.\n# @param target_key Key to retrieve\n# @param new_value New or updated value\n# @param target_ary Indexed array to scan\n# @return Returns new array with updated key (status 0) or an empty array\n#   (status 1) on failure.\n# */\n_setValueForKeyFakeAssocArray() {\n  # parameter list supports empty arguments!\n  local target_key=\"$1\"; shift\n  local new_value=\"$1\"; shift\n  local target_ary=()\n  local defaultIFS=\"$IFS\"\n  local IFS=\"$defaultIFS\"\n  local found=false\n\n  IFS=$' ' target_ary=( $1 ) IFS=\"$defaultIFS\"\n\n  [[ -z \"${target_key}\" || \"${#target_ary[@]}\" -eq 0 ]] && echo \"${value}\" && return 1\n\n  local _target_ary_length=\"${#target_ary[@]}\"\n  local i\n  for (( i=0; i<\"${_target_ary_length}\"; i++ )); do\n    local __val=\"${target_ary[$i]}\"\n\n    if [[ \"${__val%%:*}\" == \"${target_key}\" ]]; then\n      target_ary[$i]=\"${__val%%:*}:${new_value}\"\n      found=true\n      break\n    fi\n\n    unset __val\n  done\n  unset i _target_ary_length\n\n  # key not found, append\n  [[ \"$found\" == false ]] && target_ary+=( \"${target_key}:${new_value}\" )\n\n  printf \"%s\" \"${target_ary[*]}\"\n}\n\n# _valueForKeyFakeAssocArray()\n# /*!\n# @abstract Fetch value for key from a fake associative array\n# @discussion\n# Iterates over target_ary (an indexed array), searching for target_key, if the\n#   key is found its value is returned.\n#\n#   The indexed array values must conform to this format:\n#     \"key:value\"\n#   Where key and value are separated by a single colon character.\n#\n#   So-called \"fake\" associative arrays are useful for environments where the\n#   installed version of bash(1) precedes 4.0.\n# @param target_key Key to retrieve\n# @param target_ary Indexed array to scan\n# @return Returns string containing value (status 0) or an empty string\n#   (status 1) on failure.\n# */\n_valueForKeyFakeAssocArray() {\n  local target_key=\"$1\"\n  local target_ary=()\n  local defaultIFS=\"$IFS\"\n  local IFS=\"$defaultIFS\"\n  local value=\"\"\n\n  IFS=$' ' target_ary=( $2 ) IFS=\"$defaultIFS\"\n\n  [[ -z \"${target_key}\" || \"${#target_ary[@]}\" -eq 0 ]] && echo \"${value}\" && return 1\n\n  local t\n  for t in \"${target_ary[@]}\"; do\n    if [[ \"${t%%:*}\" == \"${target_key}\" ]]; then\n      value=\"${t#*:}\"\n      break\n    fi\n  done\n  unset t\n\n  echo -e \"${value}\"; return 0\n}\n\n_fetchCommitRange() {\n  local list_all=\"${1:-false}\"\n  local start_tag=\"$2\"\n  local final_tag=\"$3\"\n\n  if [[ \"$list_all\" == true ]]; then\n    git log $GIT_LOG_OPTS --pretty=format:\"${GIT_LOG_FORMAT}\"\n  elif [[ -n \"$final_tag\" && \"$start_tag\" == \"null\" ]]; then\n    git log $GIT_LOG_OPTS --pretty=format:\"${GIT_LOG_FORMAT}\" \"${final_tag}\"\n  elif [[ -n \"$final_tag\" ]]; then\n    git log $GIT_LOG_OPTS --pretty=format:\"${GIT_LOG_FORMAT}\" \"${start_tag}\"'..'\"${final_tag}\"\n  elif [[ -n \"$start_tag\" ]]; then\n    git log $GIT_LOG_OPTS --pretty=format:\"${GIT_LOG_FORMAT}\" \"${start_tag}\"'..'\n  fi | sed 's/^  \\* \\*/  */g'\n}\n\n_formatCommitPlain() {\n  local start_tag=\"$1\"\n  local final_tag=\"$2\"\n\n  printf \"%s\" \"$(_fetchCommitRange \"false\" \"$start_tag\" \"$final_tag\")\"\n}\n\n_formatCommitPretty() {\n  local title_tag=\"$1\"\n  local title_date=\"$2\"\n  local start_tag=\"$3\"\n  local final_tag=\"$4\"\n  local title=\"$title_tag / $title_date\"\n  local title_underline=\"\"\n\n  local i\n  for i in $(seq ${#title}); do\n    title_underline+=\"=\"\n  done\n  unset i\n\n  printf '\\n%s\\n%s\\n' \"$title\" \"$title_underline\"\n  printf \"\\n%s\\n\" \"$(_fetchCommitRange \"false\" \"$start_tag\" \"$final_tag\")\"\n}\n\ncommitList() {\n  # parameter list supports empty arguments!\n  local list_all=\"${1:-false}\"; shift\n  local title_tag=\"$1\"; shift\n  local start_tag=\"$1\"; shift\n  local final_tag=\"$1\"; shift\n  local list_style=\"${1:-false}\" # enable/disable list format\n  local changelog=\"$FILE\"\n  local title_date=\"$(date +'%Y-%m-%d')\"\n  local tags_list=()\n  local tags_list_keys=()\n  local defaultIFS=\"$IFS\"\n  local IFS=\"$defaultIFS\"\n\n  #\n  # Tags look like this:\n  #\n  # >git log --tags --simplify-by-decoration --date=\"short\" --pretty=\"format:%h$%x09%ad$%x09%d\"\n  #\n  # ecf1f2b$        2015-03-15$     (HEAD, tag: v1.0.1, origin/master, origin/HEAD, master, hotfix/1.0.2)\n  # a473e9c$        2015-03-04$     (tag: v1.0.0)\n  # f2cb562$        2015-02-19$     (tag: v0.9.2)\n  # 6197c2b$        2015-02-19$     (tag: v0.9.1)\n  # 1e5f5e6$        2015-02-16$     (tag: v0.9.0)\n  # 3de8ab5$        2015-02-11$     (origin/feature/restore-auto)\n  # a15afd1$        2015-02-02$     (origin/feature/versionable)\n  # 38a44e0$        2015-02-02$     (origin/feature/save-auto)\n  # 3244b80$        2015-01-16$     (origin/feature/silent-history, upstream)\n  # 85e45f8$        2014-08-25$\n  #\n  # The most-recent tag will be preceded by \"HEAD, \" if there have been zero\n  # commits since the tag. Also notice that with gitflow, we see features.\n  #\n\n  # fetch our tags\n  local _ref _date _tag _tab='%x09'\n  local _tag_regex='^[[:alnum:][:blank:][:punct:]]+/.*'\n  while IFS=$'\\t' read _ref _date _tag; do\n    [[ -z \"${_tag}\" ]] && continue\n    # strip out tags form ()\n    # git v2.2.0+ supports '%D', like '%d' without the \" (\", \")\" wrapping. One day we should use it instead.\n    _tag=\"${_tag# }\"; _tag=\"${_tag//[()]/}\"\n    # trap tag if it points to last commit (HEAD)\n    _tag=\"${_tag##HEAD, }\"\n    # strip out any additional tags pointing to same commit, remove tag label\n    _tag=\"${_tag%%,*}\"; _tag=\"${_tag#tag: }\"\n    # strip out tags that are actually feature branches (git-flow support)\n    [[ \"${_tag}\" =~ ${_tag_regex} ]] && continue\n    # add tag to assoc array; copy tag to tag_list_keys for ordered iteration\n    tags_list+=( \"${_tag}:${_ref}=>${_date}\" )\n    tags_list_keys+=( \"${_tag}\" )\n  done <<< \"$(git log --tags --simplify-by-decoration --date=\"short\" --pretty=\"format:%h${_tab}%ad${_tab}%d\")\"\n  IFS=\"$defaultIFS\"\n  unset _tag_regex\n  unset _ref _date _tag _tab\n\n  local _tags_list_keys_length=\"${#tags_list_keys[@]}\"\n  local _final_tag_found=false\n  local _start_tag_found=false\n  local i\n  for (( i=0; i<\"${_tags_list_keys_length}\"; i++ )); do\n    local __curr_tag=\"${tags_list_keys[$i]}\"\n    local __prev_tag=\"${tags_list_keys[$i+1]:-null}\"\n    local __curr_date=\"$(_valueForKeyFakeAssocArray \"${__curr_tag}\" \"${tags_list[*]}\")\"\n    __curr_date=\"${__curr_date##*=>}\"\n\n    # output latest commits, up until the most-recent tag, these are all\n    # new commits made since the last tagged commit.\n    if [[ $i -eq 0 && ( -z \"$final_tag\" || \"$final_tag\" == \"null\" ) ]]; then\n      if [[ \"$list_style\" == true ]]; then\n        _formatCommitPlain \"${__curr_tag}\" >> \"$tmpfile\"\n      else\n        _formatCommitPretty \"$title_tag\" \"$title_date\" \"${__curr_tag}\"\n      fi\n    fi\n\n    # both final_tag and start_tag are \"null\", user just wanted recent commits\n    [[ \"$final_tag\" == \"null\" && \"$start_tag\" == \"null\" ]] && break;\n\n    # find the specified final tag, continue until found\n    if [[ -n \"$final_tag\" && \"$final_tag\" != \"null\" ]]; then\n      [[ \"$final_tag\" == \"${__curr_tag}\" ]] && _final_tag_found=true\n      [[ \"$final_tag\" != \"${__curr_tag}\" && \"${_final_tag_found}\" == false ]] && continue\n    fi\n\n    # find the specified start tag, break when found\n    if [[ -n \"$start_tag\" ]]; then\n      [[ \"$start_tag\" == \"${__curr_tag}\" ]] && _start_tag_found=true\n      [[ \"$start_tag\" != \"${__curr_tag}\" && \"${_start_tag_found}\" == true ]] && break\n    fi\n\n    # output commits made between prev_tag and curr_tag, these are all of the\n    # commits related to the tag of interest.\n    if [[ \"$list_style\" == true ]]; then\n      _formatCommitPlain \"${__prev_tag}\" \"${__curr_tag}\"\n    else\n      _formatCommitPretty \"${__curr_tag}\" \"${__curr_date}\" \"${__prev_tag}\" \"${__curr_tag}\"\n    fi\n    unset __curr_date\n    unset __prev_tag\n    unset __curr_tag\n  done\n  unset i\n  unset _start_tag_found\n  unset _final_tag_found\n  unset _tags_list_keys_length\n\n  return\n}\n\ncommitListPlain() {\n  local list_all=\"${1:-false}\"\n  local start_tag=\"$2\"\n  local final_tag=\"$3\"\n\n  commitList \"$list_all\" \"\" \"$start_tag\" \"$final_tag\" \"true\"\n}\n\ncommitListPretty() {\n  local list_all=\"${1:-false}\"\n  local title_tag=\"$2\"\n  local start_tag=\"$3\"\n  local final_tag=\"$4\"\n  local title_date=\"$(date +'%Y-%m-%d')\"\n\n  commitList \"$list_all\" \"$title_tag\" \"$start_tag\" \"$final_tag\"\n}\n\nmain() {\n  local start_tag=\"null\" # empty string and \"null\" mean two different things!\n  local final_tag=\"null\"\n\n  local option=(\n    \"list_all:false\"\n    \"list_style:false\"\n    \"title_tag:$DEF_TAG_RECENT\"\n    \"start_tag:\"\n    \"final_tag:\"\n    \"output_file:\"\n    \"use_stdout:false\"\n    \"prune_old:false\"\n  )\n\n  #\n  # We work chronologically backwards from NOW towards start_tag where NOW also\n  # includes the most-recent (un-tagged) commits. If no start_tag has been\n  # specified, we work back to the very first commit; if a final_tag has been\n  # specified, we begin at the final_tag and work backwards towards start_tag.\n  #\n\n  # An existing ChangeLog/History file will be appended to the output unless the\n  # prune old (-p | --prune-old) option has been enabled.\n\n  while [ \"$1\" != \"\" ]; do\n    case $1 in\n      -a | --all )\n        option=( $(_setValueForKeyFakeAssocArray \"list_all\" true \"${option[*]}\") )\n        ;;\n      -l | --list )\n        option=( $(_setValueForKeyFakeAssocArray \"list_style\" true \"${option[*]}\") )\n        ;;\n      -t | --tag )\n        option=( $(_setValueForKeyFakeAssocArray \"title_tag\" \"$2\" \"${option[*]}\") )\n        shift\n        ;;\n      -f | --final-tag )\n        option=( $(_setValueForKeyFakeAssocArray \"final_tag\" \"$2\" \"${option[*]}\") )\n        shift\n        ;;\n      -s | --start-tag )\n        option=( $(_setValueForKeyFakeAssocArray \"start_tag\" \"$2\" \"${option[*]}\") )\n        shift\n        ;;\n      -n | --no-merges )\n        GIT_LOG_OPTS='--no-merges'\n        ;;\n      -p | --prune-old )\n        option=( $(_setValueForKeyFakeAssocArray \"prune_old\" true \"${option[*]}\") )\n        ;;\n      -x | --stdout )\n        option=( $(_setValueForKeyFakeAssocArray \"use_stdout\" true \"${option[*]}\") )\n        ;;\n      -h | ? | help | --help )\n        _usage\n        exit 1\n        ;;\n      * )\n        [[ \"${1:0:1}\" == '-' ]] && _error \"Invalid option: $1\" && _usage && exit 1\n        option=( $(_setValueForKeyFakeAssocArray \"output_file\" \"$1\" \"${option[*]}\") )\n        ;;\n    esac\n    shift\n  done\n\n  local _tag=\"$(_valueForKeyFakeAssocArray \"start_tag\" \"${option[*]}\")\"\n  if [[ -n \"${_tag}\" ]]; then\n    start_tag=\"$(git describe --tags --abbrev=0 \"${_tag}\" 2>/dev/null)\"\n    if [[ -z \"$start_tag\" ]]; then\n      _error \"Specified start-tag does not exist!\"\n      return 1\n    fi\n  fi\n  unset _tag\n\n  local _tag=\"$(_valueForKeyFakeAssocArray \"final_tag\" \"${option[*]}\")\"\n  if [[ -n \"${_tag}\" ]]; then\n    final_tag=\"$(git describe --tags --abbrev=0 \"${_tag}\" 2>/dev/null)\"\n    if [[ -z \"$final_tag\" ]]; then\n      _error \"Specified final-tag does not exist!\"\n      return 1\n    fi\n  fi\n  unset _tag\n\n  #\n  # generate changelog\n  #\n  local tmpfile=\"$(git_extra_mktemp)\"\n  local changelog=\"$(_valueForKeyFakeAssocArray \"output_file\" \"${option[*]}\")\"\n  local title_tag=\"$(_valueForKeyFakeAssocArray \"title_tag\" \"${option[*]}\")\"\n\n  if [[ \"$(_valueForKeyFakeAssocArray \"list_style\" \"${option[*]}\")\" == true ]]; then\n    if [[ \"$(_valueForKeyFakeAssocArray \"list_all\" \"${option[*]}\")\" == true ]]; then\n      commitListPlain \"true\" >> \"$tmpfile\"\n    else\n      commitListPlain \"false\" \"$start_tag\" \"$final_tag\" >> \"$tmpfile\"\n    fi\n  else\n    if [[ \"$(_valueForKeyFakeAssocArray \"list_all\" \"${option[*]}\")\" == true ]]; then\n      commitListPretty \"true\" \"$title_tag\" >> \"$tmpfile\"\n    else\n      commitListPretty \"false\" \"$title_tag\" \"$start_tag\" \"$final_tag\" >> \"$tmpfile\"\n    fi\n  fi\n\n  if [[ -z \"$changelog\" ]]; then\n    changelog=\"$(ls | egrep 'change|history' -i | head -n1)\"\n    if [[ -z \"$changelog\" ]]; then\n      changelog=\"History.md\";\n    fi\n  fi\n\n  # append existing changelog?\n  if [[ -f \"$changelog\" \\\n    && \"$(_valueForKeyFakeAssocArray \"prune_old\" \"${option[*]}\")\" == false ]]; then\n    cat \"$changelog\" >> \"$tmpfile\"\n  fi\n\n  # output file to stdout or move into place\n  if [[ \"$(_valueForKeyFakeAssocArray \"use_stdout\" \"${option[*]}\")\" == true ]]; then\n    cat \"$tmpfile\"\n    rm -f \"$tmpfile\"\n  else\n    mv -f \"$tmpfile\" \"$changelog\"\n    [[ -n \"$GIT_EDITOR\" ]] && $GIT_EDITOR \"$changelog\"\n  fi\n\n  return\n}\n\nmain \"$@\"\n\nexit 0\n","markerStore":{"nextMarkerId":6,"markersById":{"0":{"range":{"start":{"row":438,"column":32},"end":{"row":438,"column":32}},"properties":{"type":"selection","editorId":4,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/usr/local/Cellar/git-extras/3.0.0/bin/git-changelog","digestWhenLastPersisted":"2f9c930c5e12692504dc061ac7cee89b5c22f389","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":4,"softTabs":true,"scrollRow":422,"displayBuffer":{"deserializer":"DisplayBuffer","id":5,"softWrapped":true,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/usr/local/Cellar/git-extras/3.0.0/bin/git-changelog","largeFileMode":false},"largeFileMode":false}}],"activeItemURI":"/usr/local/Cellar/git-extras/3.0.0/bin/git-changelog","focused":true,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-shellscript","language-hyperlink","language-todo"],"destroyedItemURIs":[]},"packageStates":{"atom-cli-diff":{},"linter":{"scope":"File"},"find-and-replace":{"findOptions":{"findPattern":"history","replacePattern":"","pathsPattern":"","useRegex":false,"wholeWord":false,"caseSensitive":false,"inCurrentSelection":false},"findHistory":["history"],"replaceHistory":[],"pathsHistory":[]},"fuzzy-finder":{"/usr/local/Cellar/git-extras/3.0.0/bin/git-changelog":1447617214552},"metrics":{"sessionLength":403420},"tabs":[{"previewTabURI":"/usr/local/Cellar/git-extras/3.0.0/bin/git-changelog"}],"tree-view":{"directoryExpansionStates":{"/usr/local/Cellar/git-extras/3.0.0":{"isExpanded":true,"entries":{"bin":{"isExpanded":true,"entries":{}},"etc":{"isExpanded":false,"entries":{}},"share":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/usr/local/Cellar/git-extras/3.0.0/bin/git-changelog","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}},"fullScreen":false}